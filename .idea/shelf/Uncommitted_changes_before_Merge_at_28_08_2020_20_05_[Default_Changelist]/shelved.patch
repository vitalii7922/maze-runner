Index: Maze Runner/Saved and loaded/task-info.yaml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>type: edu\r\ncustom_name: stage3\r\nfiles:\r\n- name: src/maze/Main.java\r\n  visible: true\r\n  text: |\r\n    package maze;\r\n\r\n    public class Main {\r\n        public static void main(String[] args) {\r\n            System.out.println(\"Hello World!\");\r\n        }\r\n    }\r\n  learner_created: false\r\n- name: test/MazeRunnerTest.java\r\n  visible: false\r\n  text: |\r\n    import maze.Main;\r\n    import org.hyperskill.hstest.stage.StageTest;\r\n    import org.hyperskill.hstest.testcase.CheckResult;\r\n    import org.hyperskill.hstest.testcase.TestCase;\r\n\r\n    import java.util.ArrayList;\r\n    import java.util.List;\r\n    import java.util.stream.Collectors;\r\n\r\n    enum Elem {\r\n        WALL, EMPTY, PATH, DUMMY;\r\n\r\n        static Elem get(char c) {\r\n            if (c == '\\u2588') {\r\n                return WALL;\r\n            } else if (c == ' ') {\r\n                return EMPTY;\r\n            } else if (c == '/') {\r\n                return PATH;\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n\r\n    class Maze {\r\n\r\n        // maze[height][width]\r\n        // maze[row][col]\r\n        Elem[][] maze;\r\n\r\n        Maze(Maze other) {\r\n            maze = new Elem[other.getHeight()][other.getWidth()];\r\n            for (int h = 0; h < other.getHeight(); h++) {\r\n                for (int w = 0; w < other.getWidth(); w++) {\r\n                    maze[h][w] = other.maze[h][w];\r\n                }\r\n            }\r\n        }\r\n\r\n        Maze(List<String> lines) throws Exception {\r\n\r\n            int lineCount = 1;\r\n            for (String line : lines) {\r\n                if (line.length() % 2 != 0) {\r\n                    throw new Exception(\"Line \" + lineCount + \" of the maze \" +\r\n                        \"contains odd number of characters. Should be always even.\");\r\n                }\r\n\r\n                for (char c : line.toCharArray()) {\r\n                    if (Elem.get(c) == null) {\r\n                        String hex = Integer.toHexString((int)c);\r\n                        throw new Exception(\r\n                            \"Found strange symbol in the \" + lineCount +\r\n                                \" line of the maze: \\\\u\" + hex);\r\n                    }\r\n                }\r\n\r\n                int lineWidth = line.length() / 2;\r\n\r\n                for (int currWidth = 0; currWidth < lineWidth; currWidth++) {\r\n                    int currIndex = currWidth * 2;\r\n                    int nextIndex = currIndex + 1;\r\n\r\n                    char currChar = line.charAt(currIndex);\r\n                    char nextChar = line.charAt(nextIndex);\r\n\r\n                    if (currChar != nextChar) {\r\n                        throw new Exception(\"There are symbols in \" +\r\n                            \"this line that don't appear twice in a row \" +\r\n                            \"(at indexes \" + currIndex + \" and \" + nextIndex + \").\\n\" +\r\n                            \"Line: \\\"\" + line + \"\\\"\");\r\n                    }\r\n                }\r\n\r\n                lineCount++;\r\n            }\r\n\r\n            int mazeWidth = lines.get(0).length() / 2;\r\n            int mazeHeight = lines.size();\r\n\r\n            lineCount = 1;\r\n            for (String line : lines) {\r\n                if (line.length() / 2 != mazeWidth) {\r\n                    throw new Exception(\"The first line of the maze contains \" +\r\n                        lines.get(0).length() + \" characters, but the line #\" +\r\n                        lineCount + \" contains \" + line.length() + \" characters.\");\r\n                }\r\n                lineCount++;\r\n            }\r\n\r\n            maze = new Elem[mazeHeight][mazeWidth];\r\n\r\n            for (int currHeight = 0; currHeight < mazeHeight; currHeight++) {\r\n                String line = lines.get(currHeight);\r\n                for (int currWidth = 0; currWidth < mazeWidth; currWidth++) {\r\n                    char c = line.charAt(currWidth * 2);\r\n                    maze[currHeight][currWidth] = Elem.get(c);\r\n                }\r\n            }\r\n\r\n            if (maze[0][0] != Elem.WALL ||\r\n                maze[0][mazeWidth - 1] != Elem.WALL ||\r\n                maze[mazeHeight - 1][0] != Elem.WALL ||\r\n                maze[mazeHeight - 1][mazeWidth - 1] != Elem.WALL) {\r\n                throw new Exception(\"All four corners of the maze must be walls.\");\r\n            }\r\n\r\n            for (int h = 0; h <= mazeHeight - 3; h++) {\r\n                for (int w = 0; w <= mazeWidth - 3; w++) {\r\n                    if (getElem(h, w) == Elem.WALL &&\r\n                        getElem(h, w + 1) == Elem.WALL &&\r\n                        getElem(h, w + 2) == Elem.WALL &&\r\n\r\n                        getElem(h + 1, w) == Elem.WALL &&\r\n                        getElem(h + 1, w + 1) == Elem.WALL &&\r\n                        getElem(h + 1, w + 2) == Elem.WALL &&\r\n\r\n                        getElem(h + 2, w) == Elem.WALL &&\r\n                        getElem(h + 2, w + 1) == Elem.WALL &&\r\n                        getElem(h + 2, w + 2) == Elem.WALL) {\r\n\r\n                        throw new Exception(\"There are 3x3 block in the maze \" +\r\n                            \"consisting only of walls. Such blocks are not allowed.\");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        Elem[] getRow(int rowNum) {\r\n            Elem[] newRow = new Elem[getWidth()];\r\n            for (int i = 0; i < getWidth(); i++) {\r\n                newRow[i] = maze[rowNum][i];\r\n            }\r\n            return newRow;\r\n        }\r\n\r\n        Elem[] getCol(int colNum) {\r\n            Elem[] newCol = new Elem[getHeight()];\r\n            for (int i = 0; i < getHeight(); i++) {\r\n                newCol[i] = maze[i][colNum];\r\n            }\r\n            return newCol;\r\n        }\r\n\r\n        Elem getElem(int height, int width) {\r\n            return maze[height][width];\r\n        }\r\n\r\n        void setElem(int height, int width, Elem elem) {\r\n            maze[height][width] = elem;\r\n        }\r\n\r\n        int getWidth() {\r\n            return maze[0].length;\r\n        }\r\n\r\n        int getHeight() {\r\n            return maze.length;\r\n        }\r\n\r\n        Maze copy() {\r\n            return new Maze(this);\r\n        }\r\n\r\n        int count(Elem toCount) {\r\n            int sum = 0;\r\n            for (Elem[] row : maze) {\r\n                for (Elem e : row) {\r\n                    if (e == toCount) {\r\n                        sum++;\r\n                    }\r\n                }\r\n            }\r\n            return sum;\r\n        }\r\n\r\n        int countAround(int h, int w, Elem elem) {\r\n            int sum = 0;\r\n\r\n            if (h + 1 < getHeight() &&\r\n                getElem(h + 1, w) == elem) {\r\n                sum++;\r\n            }\r\n\r\n            if (h - 1 >= 0 &&\r\n                getElem(h - 1, w) == elem) {\r\n                sum++;\r\n            }\r\n\r\n            if (w + 1 < getWidth() &&\r\n                getElem(h, w + 1) == elem) {\r\n                sum++;\r\n            }\r\n\r\n            if (w - 1 >= 0 &&\r\n                getElem(h, w - 1) == elem) {\r\n                sum++;\r\n            }\r\n\r\n            return sum;\r\n        }\r\n\r\n        int countEntrances() {\r\n            int entranceCount = 0;\r\n            for (Elem[] line : new Elem[][] {\r\n                getCol(0),\r\n                getCol(getWidth() - 1),\r\n                getRow(0),\r\n                getRow(getHeight() - 1)\r\n            }) {\r\n\r\n                for (Elem e : line) {\r\n                    if (e != Elem.WALL) {\r\n                        entranceCount++;\r\n                    }\r\n                }\r\n            }\r\n            return entranceCount;\r\n        }\r\n\r\n        private void propagate(Elem from, Elem to) {\r\n            boolean didPropagate = true;\r\n            while (didPropagate) {\r\n                didPropagate = false;\r\n                for (int h = 0; h < getHeight(); h++) {\r\n                    for (int w = 0; w < getWidth(); w++) {\r\n                        if (getElem(h, w) == from) {\r\n                            if (countAround(h, w, to) > 0) {\r\n                                didPropagate = true;\r\n                                setElem(h, w, to);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        int checkAccessibility() {\r\n            int entranceHeight = 0;\r\n            int entranceWidth = 0;\r\n\r\n            findPoints: {\r\n                for (int currWidth : new int[] {0, getWidth() - 1}) {\r\n                    for (int currHeight = 0; currHeight < getHeight(); currHeight++) {\r\n                        if (getElem(currHeight, currWidth) != Elem.WALL) {\r\n                            entranceHeight = currHeight;\r\n                            entranceWidth = currWidth;\r\n                            break findPoints;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                for (int currHeight : new int[] {0, getHeight() - 1}) {\r\n                    for (int currWidth = 0; currWidth < getWidth(); currWidth++) {\r\n                        if (getElem(currHeight, currWidth) != Elem.WALL) {\r\n                            entranceHeight = currHeight;\r\n                            entranceWidth = currWidth;\r\n                            break findPoints;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            Maze copy = copy();\r\n            copy.setElem(entranceHeight, entranceWidth, Elem.PATH);\r\n            copy.propagate(Elem.EMPTY, Elem.PATH);\r\n\r\n            return copy.count(Elem.EMPTY);\r\n        }\r\n\r\n        int checkPath() throws Exception {\r\n            int entranceHeight = 0;\r\n            int entranceWidth = 0;\r\n\r\n            for (int currWidth : new int[] {0, getWidth() - 1}) {\r\n                for (int currHeight = 0; currHeight < getHeight(); currHeight++) {\r\n                    if (getElem(currHeight, currWidth) == Elem.EMPTY) {\r\n                        throw new Exception(\"If the maze is solved all \" +\r\n                            \"the entrances should be marked with '//' characters\");\r\n                    }\r\n                    if (getElem(currHeight, currWidth) == Elem.PATH) {\r\n                        entranceHeight = currHeight;\r\n                        entranceWidth = currWidth;\r\n                    }\r\n                }\r\n            }\r\n\r\n            for (int currHeight : new int[] {0, getHeight() - 1}) {\r\n                for (int currWidth = 0; currWidth < getWidth(); currWidth++) {\r\n                    if (getElem(currHeight, currWidth) == Elem.EMPTY) {\r\n                        throw new Exception(\"If the maze is solved all \" +\r\n                            \"the entrances should be marked with '//' characters\");\r\n                    }\r\n                    if (getElem(currHeight, currWidth) == Elem.PATH) {\r\n                        entranceHeight = currHeight;\r\n                        entranceWidth = currWidth;\r\n                    }\r\n                }\r\n            }\r\n\r\n            for (int h = 0; h < getHeight(); h++) {\r\n                for (int w = 0; w < getWidth(); w++) {\r\n                    if (getElem(h, w) == Elem.PATH) {\r\n                        if (countAround(h, w, Elem.PATH) >= 3) {\r\n                            throw new Exception(\"The escape path shouldn't branch off, \" +\r\n                                \"it should go in one direction.\");\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            Maze copy = copy();\r\n            copy.setElem(entranceHeight, entranceWidth, Elem.DUMMY);\r\n            copy.propagate(Elem.PATH, Elem.DUMMY);\r\n\r\n            return copy.count(Elem.PATH);\r\n        }\r\n\r\n        boolean equals(Maze other) {\r\n            if (getWidth() != other.getWidth() || getHeight() != other.getHeight()) {\r\n                return false;\r\n            }\r\n            for (int h = 0; h < getHeight(); h++) {\r\n                for (int w = 0; w < getWidth(); w++) {\r\n                    if (getElem(h, w) == Elem.WALL && other.getElem(h, w) != Elem.WALL ||\r\n                        getElem(h, w) != Elem.WALL && other.getElem(h, w) == Elem.WALL) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n\r\n        static List<Maze> parse(String text) throws Exception {\r\n\r\n            List<Maze> mazes = new ArrayList<>();\r\n\r\n            List<String> lines = text\r\n                .lines()\r\n                .collect(Collectors.toList());\r\n\r\n            lines.add(\"\");\r\n\r\n            List<String> mazeLines = new ArrayList<>();\r\n\r\n            boolean isStarted = false;\r\n            for (String line : lines) {\r\n                if (line.contains(\"\\u2588\")) {\r\n                    isStarted = true;\r\n                    mazeLines.add(line);\r\n                } else if (isStarted) {\r\n                    isStarted = false;\r\n                    Maze maze = new Maze(mazeLines);\r\n                    mazes.add(maze);\r\n                    mazeLines.clear();\r\n                }\r\n            }\r\n\r\n            return mazes;\r\n        }\r\n\r\n    }\r\n\r\n    class Clue {\r\n        int size;\r\n        Clue(int s) {\r\n            size = s;\r\n        }\r\n    }\r\n\r\n    public class MazeRunnerTest extends StageTest<Clue> {\r\n\r\n        public MazeRunnerTest() {\r\n            super(Main.class);\r\n        }\r\n\r\n        @Override\r\n        public List<TestCase<Clue>> generate() {\r\n            return List.of(\r\n                new TestCase<Clue>()\r\n                    .setInput(\"0\"),\r\n\r\n                new TestCase<Clue>()\r\n                    .setInput(\"1\\n17\\n0\")\r\n                    .setAttach(new Clue(17)),\r\n\r\n                new TestCase<Clue>()\r\n                    .setInput(\"1\\n15\\n3\\ntest_maze.txt\\n0\")\r\n                    .setAttach(new Clue(15)),\r\n\r\n                new TestCase<Clue>()\r\n                    .setInput(\"2\\ntest_maze.txt\\n4\\n0\")\r\n                    .setAttach(new Clue(15))\r\n            );\r\n        }\r\n\r\n        @Override\r\n        public CheckResult check(String reply, Clue clue) {\r\n\r\n            List<Maze> mazes;\r\n            try {\r\n                mazes = Maze.parse(reply);\r\n            } catch (Exception e) {\r\n                return CheckResult.wrong(\r\n                    e.getMessage()\r\n                );\r\n            }\r\n\r\n            if (clue == null && mazes.size() == 0) {\r\n                return CheckResult.correct();\r\n            } else if (clue == null) {\r\n                return CheckResult.wrong(\r\n                    \"In this test no maze should be shown, but one was shown. \" +\r\n                        \"Try to use \\\\u2588 character only to print the maze.\"\r\n                );\r\n            } else if (mazes.size() == 0) {\r\n                return CheckResult.wrong(\r\n                    \"No mazes found in the output. Check if you are using \" +\r\n                        \"\\\\u2588 character to print the maze.\"\r\n                );\r\n            }\r\n\r\n            if (mazes.size() > 1) {\r\n                return CheckResult.wrong(\r\n                    \"Found \" + mazes.size() + \" mazes in the output. \" +\r\n                        \"Should be only one maze.\"\r\n                );\r\n            }\r\n\r\n            Maze maze = mazes.get(0);\r\n\r\n            int entrances = maze.countEntrances();\r\n            if (entrances != 2) {\r\n                return new CheckResult(false,\r\n                    \"There are \" + entrances + \" entrances to the maze, \" +\r\n                        \"should be only two.\");\r\n            }\r\n\r\n            int emptyLeft = maze.checkAccessibility();\r\n            if (emptyLeft > 0) {\r\n                return new CheckResult(false,\r\n                    \"There are \" + emptyLeft + \" empty \" +\r\n                        \"cells that are inaccessible from the entrance of the maze \" +\r\n                        \"(or there is no way from the entrance to the exit).\"\r\n                );\r\n            }\r\n\r\n            if (maze.getHeight() != clue.size) {\r\n                return new CheckResult(false,\r\n                    \"Number of rows in the maze is incorrect. \" +\r\n                        \"It's \" + maze.getHeight() + \", but should be \" + clue.size);\r\n            }\r\n\r\n            if (maze.getWidth() != clue.size) {\r\n                return new CheckResult(false,\r\n                    \"Number of columns in the maze is incorrect. \" +\r\n                        \"It's \" + maze.getWidth() + \", but should be \" + clue.size);\r\n            }\r\n\r\n            return CheckResult.correct();\r\n        }\r\n    }\r\n  learner_created: false\r\n- name: src/maze/Direction.java\r\n  visible: true\r\n  learner_created: true\r\nfeedback_link: https://hyperskill.org/projects/47/stages/253/implement\r\nstatus: Unchecked\r\nrecord: 3\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Maze Runner/Saved and loaded/task-info.yaml	(revision 81827da23e596088baecdf3c2a14b130f4d3d994)
+++ Maze Runner/Saved and loaded/task-info.yaml	(date 1598634323988)
@@ -482,6 +482,13 @@
 - name: src/maze/Direction.java
   visible: true
   learner_created: true
+- name: test_maze.txt
+  visible: true
+  learner_created: true
 feedback_link: https://hyperskill.org/projects/47/stages/253/implement
-status: Unchecked
+status: Solved
+feedback:
+  message: Congratulations! Continue on <a href="https://hyperskill.org/projects/47/stages/253/implement">JetBrains
+    Academy</a>
+  time: Fri, 28 Aug 2020 10:01:46 UTC
 record: 3
